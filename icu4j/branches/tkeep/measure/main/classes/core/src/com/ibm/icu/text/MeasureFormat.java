/*
**********************************************************************
* Copyright (c) 2004-2011, International Business Machines
* Corporation and others.  All Rights Reserved.
**********************************************************************
* Author: Alan Liu
* Created: April 20, 2004
* Since: ICU 3.0
**********************************************************************
*/
package com.ibm.icu.text;

import java.io.Externalizable;
import java.io.IOException;
import java.io.InvalidObjectException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.ObjectStreamException;
import java.text.FieldPosition;
import java.text.ParsePosition;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collection;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.MissingResourceException;
import java.util.Set;
import java.util.TreeMap;

import com.ibm.icu.impl.BundleCollection;
import com.ibm.icu.impl.ICUResourceBundle;
import com.ibm.icu.impl.SimpleCache;
import com.ibm.icu.util.Currency;
import com.ibm.icu.util.Measure;
import com.ibm.icu.util.MeasureUnit;
import com.ibm.icu.util.ULocale;
import com.ibm.icu.util.ULocale.Category;
import com.ibm.icu.util.UResourceBundle;

/**
 * A formatter for Measure objects.  This is an abstract base class.
 *
 * <p>To format or parse a Measure object, first create a formatter
 * object using a MeasureFormat factory method.  Then use that
 * object's format and parse methods.
 *
 * @see com.ibm.icu.text.UFormat
 * @author Alan Liu
 * @stable ICU 3.0
 */
public class MeasureFormat extends UFormat {
    // Generated by serialver from JDK 1.4.1_01
    static final long serialVersionUID = -7182021401701778240L;
    
    /**
     * General purpose formatting width enum.
     * @draft ICU 53
     * @provisional
     */
    public static enum FormatWidth {
        
        /**
         * @draft ICU 53
         * @provisional
         */
        WIDE("units"), 
        
        /**
         * @draft ICU 53
         * @provisional
         */
        SHORT("unitsShort"), 
        
        /**
         * @draft ICU 53
         * @provisional
         */
        NARROW("unitsNarrow");
    
        final String resourceKey;
    
        private FormatWidth(String resourceKey) {
            this.resourceKey = resourceKey;
        }
    }
    
    /**
     * Format a sequence of measures (type-safe). Uses the ListFormatter unit lists.
     * So, for example, one could format “3 feet, 2 inches”.
     * Zero values are formatted (eg, “3 feet, 0 inches”). It is the caller’s
     * responsibility to have the appropriate values in appropriate order,
     * and using the appropriate Number values. Typically the units should be
     * in descending order, with all but the last Measure having integer values
     * (eg, not “3.2 feet, 2 inches”).
     * 
     * @param measures a sequence of one or more measures.
     * @return the formatted string.
     * @draft ICU 53
     * @provisional
     */
    public String formatMeasures(Measure... measures) {
        StringBuilder result = this.formatMeasures(
                new StringBuilder(), new FieldPosition(0), measures);
        return result.toString();
    }
    
    /**
     * Able to format Collection&lt;? extends Measure&gt;, Measure[], and Measure.
     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)
     */
    @Override
    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {
        if (obj instanceof Collection) {
            Collection<?> coll = (Collection<?>) obj;
            Measure[] measures = new Measure[coll.size()];
            int idx = 0;
            for (Object o : coll) {
                if (!(o instanceof Measure)) {
                    throw new IllegalArgumentException(obj.toString());
                }
                measures[idx++] = (Measure) o;
            }
            return formatMeasures(toAppendTo, pos, measures);
        } else if (obj instanceof Measure[]) {
            return formatMeasures(toAppendTo, pos, (Measure[]) obj);
        } else if (obj instanceof Measure){
            return this.formatMeasure((Measure) obj, toAppendTo, pos);
        } else {
            throw new IllegalArgumentException(obj.toString());            
        }
    }
    
    /**
     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)
     */
    @Override
    public Measure parseObject(String source, ParsePosition pos) {
        
        ParseData parseData = parseDataCache.get(locale);
        if (parseData == null) {
            parseData = new ParseData(locale, this.unitToStyleToCountToFormat);
            parseDataCache.put(locale, parseData);
        }
        return parseData.parse(numberFormat, source, pos);
    }
    
    /**
     * Formats a measure and adds to appendable.
     * 
     * @param measure the measure to format
     * @param appendable the formatted string appended here.
     * @param fieldPosition 
     * @return appendable.
     * @see MeasureFormat#format(Measure...)
     * @draft ICU 53
     * @provisional
     */
    public <T extends Appendable> T formatMeasure(
            Measure measure, T appendable, FieldPosition fieldPosition) {
        Number n = measure.getNumber();
        MeasureUnit unit = measure.getUnit();        
        UFieldPosition fpos = new UFieldPosition(fieldPosition.getFieldAttribute(), fieldPosition.getField());
        StringBuffer formattedNumber = numberFormat.format(n, new StringBuffer(), fpos);
        String keyword = rules.select(new PluralRules.FixedDecimal(n.doubleValue(), fpos.getCountVisibleFractionDigits(), fpos.getFractionDigits()));

        Map<FormatWidth, Map<String, PatternData>> styleToCountToFormat = unitToStyleToCountToFormat.get(unit);
        Map<String, PatternData> countToFormat = styleToCountToFormat.get(length);
        PatternData messagePatternData = countToFormat.get(keyword);
        try {
            appendable.append(messagePatternData.prefix);
            if (messagePatternData.suffix != null) { // there is a number (may not happen with, say, Arabic dual)
                // Fix field position
                fieldPosition.setBeginIndex(fpos.getBeginIndex() + messagePatternData.prefix.length());
                fieldPosition.setEndIndex(fpos.getEndIndex() + messagePatternData.prefix.length());
                appendable.append(formattedNumber);
                appendable.append(messagePatternData.suffix);
            }
            return appendable;
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    /**
     * Formats a sequence of measures and adds to appendable.
     * 
     * @param appendable the formatted string appended here.
     * @param fieldPosition 
     * @param measures the measures to format.
     * @return appendable.
     * @see MeasureFormat#format(Measure...)
     * @draft ICU 53
     * @provisional
     */
    @SuppressWarnings("unchecked")
    public <T extends Appendable> T formatMeasures(
            T appendable, FieldPosition fieldPosition, Measure... measures) {
        StringBuilder[] results = new StringBuilder[measures.length];
        for (int i = 0; i < measures.length; ++i) {
            results[i] = formatMeasure(measures[i], new StringBuilder(), fieldPosition);
        }
        ListFormatter listFormatter = ListFormatter.getInstance(locale, 
                length == FormatWidth.WIDE ? ListFormatter.Style.DURATION : ListFormatter.Style.DURATION_SHORT);
        // This is safe because appendable is of type T.
        try {
            return (T) appendable.append(listFormatter.format((Object[]) results));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    
    /**
     * For two MeasureFormat objects, a and b, to be equal, they must be of the same class and
     * a.equalsSameClass(b) must be true.
     */
    @Override
    public final boolean equals(Object other) {
        if (this == other) {
            return true;
        }
        if (!(other instanceof MeasureFormat)) {
            return false;
        }
        if (!getClass().equals(other.getClass())) {
            return false;
        }
        return equalsSameClass((MeasureFormat) other);
    }
    
    @Override
    public int hashCode() {
        return (numberFormat.hashCode() * 31 + locale.hashCode()) * 31 + length.hashCode();
    }
    
    /**
     * Returns true if this object is equal to other. The class of this and the class of other
     * are guaranteed to be equal.
     */
    protected boolean equalsSameClass(MeasureFormat other) {
        return objEquals(numberFormat,other.numberFormat)
                && objEquals(locale, other.locale) && objEquals(length, other.length);        
    }
    
    
    /**
     * Get the format width this instance is using.
     * @draft ICU 53
     * @provisional
     */
    public MeasureFormat.FormatWidth getWidth() {
        return length;
    }
    
    /**
     * Get the locale of this instance.
     * @draft ICU 53
     * @provisional
     */
    public ULocale getLocale() {
        return locale;
    }
    
    /**
     * Get a copy of the number format.
     * @draft ICU 53
     * @provisional
     */
    public NumberFormat getNumberFormat() {
        synchronized (numberFormat) {
            return (NumberFormat) numberFormat.clone();
        }
    }
    
    /**
     * Create a format from the locale, length, and format.
     *
     * @param locale the locale.
     * @param width
     * @return The new MeasureFormat object.
     * @draft ICU 53
     * @provisional
     */
    public static MeasureFormat getInstance(ULocale locale, FormatWidth width) {
        return getInstance(locale, width, NumberFormat.getInstance(locale));
    }
    
    /**
     * Create a format from the locale, length, and format.
     *
     * @param locale the locale.
     * @param width
     * @param format This is defensively copied.
     * @return The new MeasureFormat object.
     * @draft ICU 53
     * @provisional
     */
    public static MeasureFormat getInstance(ULocale locale, FormatWidth width, NumberFormat format) {
        PluralRules rules = PluralRules.forLocale(locale);
        Map<MeasureUnit, EnumMap<FormatWidth, Map<String, PatternData>>> unitToStyleToCountToFormat; 
        unitToStyleToCountToFormat = localeToUnitToStyleToCountToFormat.get(locale);
        if (unitToStyleToCountToFormat == null) {
            unitToStyleToCountToFormat = loadLocaleData(locale, rules);
            localeToUnitToStyleToCountToFormat.put(locale, unitToStyleToCountToFormat);
        }
        return new MeasureFormat(locale, width, format, rules, unitToStyleToCountToFormat);
    }

    /**
     * Return a formatter for CurrencyAmount objects in the given
     * locale.
     * @param locale desired locale
     * @return a formatter object
     * @stable ICU 3.0
     */
    public static MeasureFormat getCurrencyFormat(ULocale locale) {
        return new CurrencyFormat(locale);
    }

    /**
     * Return a formatter for CurrencyAmount objects in the default
     * <code>FORMAT</code> locale.
     * @return a formatter object
     * @see Category#FORMAT
     * @stable ICU 3.0
     */
    public static MeasureFormat getCurrencyFormat() {
        return getCurrencyFormat(ULocale.getDefault(Category.FORMAT));
    }
    
    private final transient ULocale locale;
    
    // NumberFormat is known to lack thread-safety, all access to this
    // field must be synchronized.
    private final transient NumberFormat numberFormat;
    
    private final transient FormatWidth length;
    
    // PluralRules is documented as being immutable which implies thread-safety.
    private final transient PluralRules rules;
    
    // Measure unit -> format width -> plural form -> pattern ("{0} meters")
    private final transient Map<MeasureUnit, EnumMap<FormatWidth, Map<String, PatternData>>> unitToStyleToCountToFormat;

    static final SimpleCache<ULocale,Map<MeasureUnit, EnumMap<FormatWidth, Map<String, PatternData>>>> localeToUnitToStyleToCountToFormat
            = new SimpleCache<ULocale,Map<MeasureUnit, EnumMap<FormatWidth, Map<String, PatternData>>>>();
    
    static final SimpleCache<ULocale, ParseData> parseDataCache =
            new SimpleCache<ULocale, ParseData>();
 
    
    private MeasureFormat(
            ULocale locale,
            FormatWidth width,
            NumberFormat format,
            PluralRules rules,
            Map<MeasureUnit, EnumMap<FormatWidth, Map<String, PatternData>>> unitToStyleToCountToFormat) {
        this.locale = locale;
        this.length = width;
        this.numberFormat = format;
        this.rules = rules;
        this.unitToStyleToCountToFormat = unitToStyleToCountToFormat;
    }
    
    /**
     * For backward compatibility only.
     * @internal
     * @deprecated
     */
    protected MeasureFormat() {
        // Make compiler happy by setting final fields to null.
        this.length = null;
        this.locale = null;
        this.numberFormat = null;
        this.rules = null;
        this.unitToStyleToCountToFormat = null;
        
    }
    
    /**
     * Returns formatting data for all MeasureUnits except for currency ones.
     */
    private static Map<MeasureUnit, EnumMap<FormatWidth, Map<String, PatternData>>> loadLocaleData(
            ULocale locale, PluralRules rules) {
        Set<String> keywords = rules.getKeywords();
        Map<MeasureUnit, EnumMap<FormatWidth, Map<String, PatternData>>> unitToStyleToCountToFormat
                = new HashMap<MeasureUnit, EnumMap<FormatWidth, Map<String, PatternData>>>();
        ICUResourceBundle resource = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, locale);
        for (MeasureUnit unit : MeasureUnit.getAvailable()) {
            // Currency data cannot be found here. Skip.
            if (unit instanceof Currency) {
                continue;
            }
            EnumMap<FormatWidth, Map<String, PatternData>> styleToCountToFormat = unitToStyleToCountToFormat.get(unit);
            if (styleToCountToFormat == null) {
                unitToStyleToCountToFormat.put(unit, styleToCountToFormat = new EnumMap<FormatWidth, Map<String, PatternData>>(FormatWidth.class));
            }
            for (FormatWidth styleItem : FormatWidth.values()) {
                try {
                    ICUResourceBundle unitTypeRes = resource.getWithFallback(styleItem.resourceKey);
                    ICUResourceBundle unitsRes = unitTypeRes.getWithFallback(unit.getType());
                    ICUResourceBundle oneUnitRes = unitsRes.getWithFallback(unit.getSubtype());
                    Map<String, PatternData> countToFormat = styleToCountToFormat.get(styleItem);
                    if (countToFormat == null) {
                        styleToCountToFormat.put(styleItem, countToFormat = new HashMap<String, PatternData>());
                    }
                    // TODO(rocketman): Seems like we should be iterating over the bundles in
                    // oneUnitRes instead of all the plural key words since most languages have
                    // just 1 or 2 forms.
                    for (String keyword : keywords) {
                        UResourceBundle countBundle;
                        try {
                            countBundle = oneUnitRes.get(keyword);
                        } catch (MissingResourceException e) {
                            continue;
                        }
                        String pattern = countBundle.getString();
                        //                        System.out.println(styleItem.resourceKey + "/" 
                        //                                + unit.getType() + "/" 
                        //                                + unit.getCode() + "/" 
                        //                                + keyword + "=" + pattern);
                        PatternData format = new PatternData(pattern);
                        countToFormat.put(keyword, format);
                        //                        System.out.println(styleToCountToFormat);
                    }
                    // fill in 'other' for any missing values
                    PatternData other = countToFormat.get("other");
                    for (String keyword : keywords) {
                        if (!countToFormat.containsKey(keyword)) {
                            countToFormat.put(keyword, other);
                        }
                    }
                } catch (MissingResourceException e) {
                    continue;
                }
            }
            // now fill in the holes
            fillin:
                if (styleToCountToFormat.size() != FormatWidth.values().length) {
                    Map<String, PatternData> fallback = styleToCountToFormat.get(FormatWidth.SHORT);
                    if (fallback == null) {
                        fallback = styleToCountToFormat.get(FormatWidth.WIDE);
                    }
                    if (fallback == null) {
                        break fillin; // TODO use root
                    }
                    for (FormatWidth styleItem : FormatWidth.values()) {
                        Map<String, PatternData> countToFormat = styleToCountToFormat.get(styleItem);
                        if (countToFormat == null) {
                            styleToCountToFormat.put(styleItem, countToFormat = new HashMap<String, PatternData>());
                            for (Entry<String, PatternData> entry : fallback.entrySet()) {
                                countToFormat.put(entry.getKey(), entry.getValue());
                            }
                        }
                    }
                }
        }
        return unitToStyleToCountToFormat;
    }
    
    private static final class ParseData {
        private final Map<String,BitSet> prefixMap;
        private final Map<String,BitSet> suffixMap;
        private final BitSet nullSuffix;
        private final Index<MeasureUnit> index;

        ParseData(ULocale locale, Map<MeasureUnit, EnumMap<FormatWidth, Map<String, PatternData>>> unitToStyleToCountToFormat) {
            prefixMap = new TreeMap<String,BitSet>(LONGEST_FIRST);
            suffixMap = new TreeMap<String,BitSet>(LONGEST_FIRST);
            nullSuffix = new BitSet();
            index = new Index<MeasureUnit>();
            for (Entry<MeasureUnit, EnumMap<FormatWidth, Map<String, PatternData>>> entry3 : unitToStyleToCountToFormat.entrySet()) {
                MeasureUnit unit = entry3.getKey();
                int unitIndex = index.addItem(unit);
                for (Entry<FormatWidth, Map<String, PatternData>> entry : entry3.getValue().entrySet()) {
                    //Style style = entry.getKey();
                    for (Entry<String, PatternData> entry2 : entry.getValue().entrySet()) {
                        //String keyword = entry2.getKey();
                        PatternData data = entry2.getValue();
                        setBits(prefixMap, data.prefix, unitIndex);
                        if (data.suffix == null) {
                            nullSuffix.set(unitIndex);
                        } else {
                            setBits(suffixMap, data.suffix, unitIndex);
                        }
                    }
                }
            }
        }
        private void setBits(Map<String, BitSet> map, String string, int unitIndex) {
            BitSet bs = map.get(string);
            if (bs == null) {
                map.put(string, bs = new BitSet());
            }
            bs.set(unitIndex);
        }

        private Measure parse(NumberFormat numberFormat, String toParse, ParsePosition parsePosition) {
            // TODO optimize this as necessary
            // In particular, if we've already matched a suffix and number, store that.
            // If the same suffix turns up we can jump
            int startIndex = parsePosition.getIndex();
            Number bestNumber = null;
            int bestUnit = -1;
            int longestMatch = -1;
            int furthestError = -1;
            for (Entry<String, BitSet> prefixEntry : prefixMap.entrySet()) {
                String prefix = prefixEntry.getKey();
                BitSet prefixSet = prefixEntry.getValue();
                for (Entry<String, BitSet> suffixEntry : suffixMap.entrySet()) {
                    String suffix = suffixEntry.getKey();
                    BitSet suffixSet = suffixEntry.getValue();
                    parsePosition.setIndex(startIndex);
                    if (looseMatches(prefix, toParse, parsePosition)) {
                        //                    if (nullSuffix.intersects(prefixSet))
                        ////                        // can only happen with singular rule
                        ////                        if (longestMatch < parsePosition.getIndex()) {
                        ////                            longestMatch = parsePosition.getIndex();
                        ////                            Collection<Double> samples = rules.getSamples(keyword);
                        ////                            bestNumber = samples.iterator().next();
                        ////                            bestUnit = unit;
                        ////                        }
                        //                    }
                        Number number = numberFormat.parse(toParse, parsePosition);
                        if (parsePosition.getErrorIndex() >= 0) {
                            if (furthestError < parsePosition.getErrorIndex()) {
                                furthestError = parsePosition.getErrorIndex();
                            }
                            continue;
                        }
                        if (looseMatches(suffix, toParse, parsePosition) && prefixSet.intersects(suffixSet)) {
                            if (longestMatch < parsePosition.getIndex()) {
                                longestMatch = parsePosition.getIndex();
                                bestNumber = number;
                                bestUnit = getFirst(prefixSet, suffixSet);
                            }
                        } else if (furthestError < parsePosition.getErrorIndex()) {
                            furthestError = parsePosition.getErrorIndex();
                        } 
                    } else if (furthestError < parsePosition.getErrorIndex()) {
                        furthestError = parsePosition.getErrorIndex();
                    } 

                }
            }
            if (longestMatch >= 0) {
                parsePosition.setIndex(longestMatch);
                return new Measure(bestNumber, index.getUnit(bestUnit));
            }
            parsePosition.setErrorIndex(furthestError);
            return null;
        }
    }
    
    /**
     * Index is like a List<T> except that its elements must be unique.
     * It offers an indexOf() that runs in O(1) time. 
     */
    static class Index<T> {
        List<T> intToItem = new ArrayList<T>();
        Map<T,Integer> itemToInt = new HashMap<T,Integer>();

        /**
         * Like indexOf. Returns -1 if item is not in list.
         * @param item
         * @return
         */
        int getIndex(T item) {
            Integer result = itemToInt.get(item);
            return result == null ? -1 : result.intValue();
        }
        
        /**
         * Like List.get()
         */
        T getUnit(int index) {
            return intToItem.get(index);
        }
        
        /**
         * Like List.add() but returns the index of newly added item. If item was already
         * in the list, it returns its existing index without adding it again.
         */
        int addItem(T item) {
            Integer index = itemToInt.get(item);
            if (index != null) {
                return index;
            }
            int size = intToItem.size();
            itemToInt.put(item, size);
            intToItem.add(item);
            return size;
        }
    }
    
    static final class PatternData {
        final String prefix;
        final String suffix;
        public PatternData(String pattern) {
            int pos = pattern.indexOf("{0}");
            if (pos < 0) {
                prefix = pattern;
                suffix = null;
            } else {
                prefix = pattern.substring(0,pos);
                suffix = pattern.substring(pos+3);
            }
        }
        public String toString() {
            return prefix + "; " + suffix;
        }

    }

    
    /**
     * Returns the lowest i that is in both prefix set or suffix set.  If prefixSet and
     * suffixSet don't instersect, returns -1.
     */
    private static int getFirst(BitSet prefixSet, BitSet suffixSet) {
        int prefixIdx = prefixSet.nextSetBit(0);
        int suffixIdx = suffixSet.nextSetBit(0);
        while (prefixIdx != -1 && suffixIdx != -1) {
            if (prefixIdx == suffixIdx) {
                return prefixIdx;
            }
            else if (prefixIdx > suffixIdx) {
                suffixIdx = suffixSet.nextSetBit(prefixIdx);
            } else {
                prefixIdx = prefixSet.nextSetBit(suffixIdx);
            }
        }
        return -1;
    }
    
    /**
     * loosMatches returns true if pattern is an exact match of text at position pos.
     * That is it returns pattern == text[pos:pos + len(pattern)]
     * @param pattern the pattern string
     * @param text the text
     * @param pos On return false, sets error index to index. On return true, indrements index
     * by len(pattern)
     * @return true if match or false otherwise.
     */
    private static boolean looseMatches(String pattern, String text, ParsePosition pos) {
        boolean matches = pattern.regionMatches(0, text, pos.getIndex(), pattern.length());
        if (matches) {
            pos.setErrorIndex(-1);
            pos.setIndex(pos.getIndex() + pattern.length());
        } else {
            pos.setErrorIndex(pos.getIndex());
        }
        return matches;
    }
    
    private static boolean objEquals(Object lhs, Object rhs) {
        return lhs == null ? rhs == null : lhs.equals(rhs);
        
    }

    /**
     * LONGEST_FIRST orders strings by the longest first follwed by the shortest. On tie for
     * length, orders lexographically.
     */
    static final Comparator<String> LONGEST_FIRST = new Comparator<String>() {
        public int compare(String as, String bs) {
            if (as.length() > bs.length()) {
                return -1;
            }
            if (as.length() < bs.length()) {
                return 1;
            }
            return as.compareTo(bs);
        }
    };
    
    MeasureFormat withLocale(ULocale locale) {
        return new MeasureFormat(
                locale,
                this.length,
                this.numberFormat,
                this.rules,
                this.unitToStyleToCountToFormat);        
    }

    MeasureFormat withNumberFormat(NumberFormat format) {
        return new MeasureFormat(
                this.locale,
                this.length,
                (NumberFormat) format.clone(),
                this.rules,
                this.unitToStyleToCountToFormat);
    }
    
    static class TimeUnitBundles extends BundleCollection {
    }
    
    static class CurrencyBundles extends BundleCollection {
    }
    
    Object toTimeUnitProxy(TimeUnitBundles bundles) {
        MeasureBundles measureBundles = new MeasureBundles();
        measureBundles.setTimeUnitBundles(new TimeUnitBundles());
        return new MeasureProxy(locale, length, numberFormat, measureBundles);
    }
    
    Object toCurrencyProxy(CurrencyBundles bundles) {
        MeasureBundles measureBundles = new MeasureBundles();
        measureBundles.setCurrencyBundles(new CurrencyBundles());
        return new MeasureProxy(locale, length, numberFormat, measureBundles);
    }
    
    private Object writeReplace() throws ObjectStreamException {
        return new MeasureProxy(locale, length, numberFormat, new MeasureBundles());
    }
    
    static class MeasureProxy implements Externalizable {
        private static final long serialVersionUID = -6033308329886716770L;
        
        private ULocale locale;
        private FormatWidth length;
        private NumberFormat numberFormat;
        private MeasureBundles bundles;

        public MeasureProxy(
                ULocale locale, FormatWidth length, NumberFormat numberFormat, MeasureBundles bundles) {
            this.locale = locale;
            this.length = length;
            this.numberFormat = numberFormat;
            this.bundles = bundles;
        }

        // Must have public constructor, to enable Externalizable
        public MeasureProxy() {
        }

        public void writeExternal(ObjectOutput out) throws IOException {
            out.writeObject(locale);
            out.writeObject(length);
            out.writeObject(numberFormat);
            bundles.write(out);
        }

        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
            locale = (ULocale) in.readObject();
            length = (FormatWidth) in.readObject();
            numberFormat = (NumberFormat) in.readObject();
            bundles = new MeasureBundles();
            bundles.read(in);     
        }

        private Object readResolve() throws ObjectStreamException {
            if (bundles.getTimeUnitBundles() != null) {
                int style;
                if (length == FormatWidth.WIDE) {
                    style = TimeUnitFormat.FULL_NAME;
                } else if (length == FormatWidth.SHORT) {
                    style = TimeUnitFormat.ABBREVIATED_NAME;
                } else {
                    throw new InvalidObjectException("Bad width: " + length);
                }
                TimeUnitFormat result = new TimeUnitFormat(locale, style);
                result.setNumberFormat(numberFormat);
                return result;
            } else if (bundles.getCurrencyBundles() != null) {
                return new CurrencyFormat(locale);
            } else {
                return MeasureFormat.getInstance(locale, length, numberFormat);
            }
        }
    }
    
    private static class MeasureBundles extends BundleCollection {
        
        private static final int TIMEUNIT_TAG = 1;
        private static final int CURRENCY_TAG = 2;
        
        public TimeUnitBundles getTimeUnitBundles() {
            return (TimeUnitBundles) getById(TIMEUNIT_TAG);
        }
        
        public void setTimeUnitBundles(TimeUnitBundles bundles) {
            setById(TIMEUNIT_TAG, bundles);
        }
        
        public CurrencyBundles getCurrencyBundles() {
            return (CurrencyBundles) getById(CURRENCY_TAG);
        }
        
        public void setCurrencyBundles(CurrencyBundles bundles) {
            setById(CURRENCY_TAG, bundles);
        }
        
        
        @Override
        protected PayloadSpec getPayloadSpec(int id) {
            if (id == TIMEUNIT_TAG) {
                return PayloadSpec.forBundleCollection(TimeUnitBundles.class);
            } else if (id == CURRENCY_TAG) {
                return PayloadSpec.forBundleCollection(CurrencyBundles.class);
            } else {
                return null;
            }
        }
    }
}
